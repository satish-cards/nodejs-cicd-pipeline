# GitHub Actions CI Workflow Documentation

## Overview

The CI (Continuous Integration) workflow automatically builds, tests, and validates the Node.js application on every push and pull request. This ensures code quality and prevents broken code from being merged.

## Workflow File

**Location**: `.github/workflows/ci.yml`

## Trigger Events

The workflow runs automatically on:
- **Push**: Any branch push
- **Pull Request**: Any pull request to any branch

```yaml
on:
  push:
    branches:
      - '**'
  pull_request:
    branches:
      - '**'
```

## Jobs

### 1. Install Dependencies

**Purpose**: Install and cache npm dependencies

**Steps**:
1. Checkout code
2. Setup Node.js 18
3. Run `npm ci` to install dependencies with clean slate
4. Cache `node_modules` for subsequent jobs

**Why npm ci?**
- Faster than `npm install`
- Uses exact versions from `package-lock.json`
- Ensures reproducible builds
- Verifies package integrity

### 2. Lint Code

**Purpose**: Enforce code quality and style standards

**Steps**:
1. Checkout code
2. Setup Node.js 18
3. Restore cached dependencies
4. Run ESLint: `npm run lint`

**What it checks**:
- Code style consistency
- Common JavaScript errors
- Best practices violations
- Unused variables

**Fails if**: Any linting errors are found

### 3. Run Tests with Coverage

**Purpose**: Verify application functionality and track test coverage

**Steps**:
1. Checkout code
2. Setup Node.js 18
3. Restore cached dependencies
4. Run Jest tests: `npm test`
5. Upload coverage reports as artifacts

**What it tests**:
- Unit tests for all routes
- Middleware functionality
- Error handling
- Integration tests

**Coverage reports**: Available as downloadable artifacts in GitHub Actions UI

**Fails if**: Any test fails

### 4. Build Docker Image and Push to GHCR

**Purpose**: Build Docker image, test it, and push to GitHub Container Registry

**Steps**:
1. Checkout code
2. Setup Docker Buildx (advanced build features)
3. Read package.json for semantic versioning
4. Authenticate with GitHub Container Registry (GHCR)
5. Extract Docker metadata for tagging
6. Build Docker image locally for testing
7. Test the built image:
   - Start container
   - Wait 5 seconds for startup
   - Curl health endpoint
   - Stop and remove container
8. Build and push image to GHCR with multiple tags
9. Verify push succeeded

**Image tagging strategy**:
- `ghcr.io/{repository}:{commit-sha}` - Specific commit version
- `ghcr.io/{repository}:v{version}` - Semantic version from package.json
- `ghcr.io/{repository}:latest` - Latest version (main branch only)

**Authentication**: Uses `GITHUB_TOKEN` (automatically provided by GitHub Actions)

**Caching**: Uses GitHub Actions cache for Docker layers

**Fails if**: 
- Docker build fails
- Container doesn't start
- Health check fails
- Push to GHCR fails

### 5. CI Status Check

**Purpose**: Aggregate status of all jobs

**Steps**:
1. Check results of lint, test, and build jobs
2. Fail if any job failed
3. Pass if all jobs succeeded

**Why needed?**: Provides single status check for branch protection rules

## Job Dependencies

```
install
  ├── lint
  └── test
       └── build
            └── status
```

- `lint` and `test` run in parallel after `install`
- `build` runs only after both `lint` and `test` succeed
- `status` runs after all jobs complete (even if some fail)

## Caching Strategy

**Node modules caching**:
- Key: `${{ runner.os }}-node-modules-${{ hashFiles('package-lock.json') }}`
- Invalidated when: `package-lock.json` changes
- Benefit: Faster dependency installation

**Docker layer caching**:
- Type: GitHub Actions cache
- Benefit: Faster Docker builds

## Status Checks

The following status checks are reported to GitHub:
1. ✅ Install Dependencies
2. ✅ Lint Code
3. ✅ Run Tests with Coverage
4. ✅ Build Docker Image
5. ✅ CI Status Check

## Branch Protection Integration

To require CI to pass before merging:

1. Go to repository Settings → Branches
2. Add branch protection rule for `main`
3. Enable "Require status checks to pass before merging"
4. Select required checks:
   - Lint Code
   - Run Tests with Coverage
   - Build Docker Image
   - CI Status Check

See [Branch Protection Setup Guide](branch-protection-setup.md) for detailed instructions.

## Artifacts

**Coverage Reports**:
- Generated by: Test job
- Location: `coverage/` directory
- Available for: 90 days (GitHub default)
- Download from: Actions run summary page

## Performance

**Typical execution times**:
- Install: ~30 seconds (with cache)
- Lint: ~10 seconds
- Test: ~15 seconds
- Build: ~60 seconds (with cache)
- **Total**: ~2 minutes

## Troubleshooting

### Workflow Not Triggering

**Problem**: Workflow doesn't run on push

**Solutions**:
1. Check workflow file is in `.github/workflows/` directory
2. Verify YAML syntax is valid
3. Ensure branch name matches trigger pattern
4. Check GitHub Actions is enabled in repository settings

### Lint Job Failing

**Problem**: ESLint errors prevent merge

**Solutions**:
1. Run `npm run lint` locally to see errors
2. Fix linting errors in code
3. Or run `npm run lint -- --fix` to auto-fix some issues
4. Commit and push fixes

### Test Job Failing

**Problem**: Tests fail in CI but pass locally

**Solutions**:
1. Check for environment-specific issues
2. Verify all dependencies are in `package.json`
3. Look for timing issues in tests
4. Check test logs in GitHub Actions UI
5. Run tests with same Node version (18) locally

### Build Job Failing

**Problem**: Docker build fails or health check times out

**Solutions**:
1. Test Docker build locally: `docker build -t test .`
2. Check Dockerfile syntax
3. Verify all required files are included (not in `.dockerignore`)
4. Increase health check timeout if needed
5. Check application logs: `docker logs test-container`

### Cache Issues

**Problem**: Builds are slow or using stale dependencies

**Solutions**:
1. Clear cache: Go to Actions → Caches → Delete cache
2. Update `package-lock.json`: `npm install`
3. Verify cache key in workflow file

## Best Practices

1. **Run CI locally before pushing**
   ```bash
   npm run lint
   npm test
   docker build -t test .
   ```

2. **Keep CI fast**
   - Use caching effectively
   - Run only necessary tests
   - Parallelize independent jobs

3. **Fix broken builds immediately**
   - Don't push more changes on top of failures
   - Investigate and fix root cause
   - Consider reverting if fix takes too long

4. **Monitor CI performance**
   - Track execution times
   - Optimize slow jobs
   - Update dependencies regularly

5. **Use meaningful commit messages**
   - CI logs reference commit messages
   - Helps debugging failed builds
   - Improves team communication

## CD Workflows

In addition to the CI workflow, the project includes two Continuous Deployment (CD) workflows:

### CD - Staging Deployment

**Location**: `.github/workflows/cd-staging.yml`

**Trigger**: Automatic on push to `main` branch

**Purpose**: Automatically deploy to staging environment after successful CI

**Jobs**:
1. Build and push Docker image to GHCR
2. Update staging Kubernetes manifests
3. Commit changes to trigger ArgoCD sync
4. Verify deployment health

See staging workflow file for details.

### CD - Production Deployment

**Location**: `.github/workflows/cd-production.yml`

**Trigger**: Manual via workflow_dispatch

**Purpose**: Deploy to production with manual approval and rollback capability

**How to trigger**:
1. Go to Actions tab in GitHub
2. Select "CD - Production Deployment"
3. Click "Run workflow"
4. Enter image tag (commit SHA from staging)
5. Enter deployment reason
6. Click "Run workflow"

**Jobs**:
1. **Manual Approval**: Requires approval via GitHub environment protection (24-hour timeout)
2. **Backup Current State**: Records current production version for rollback
3. **Update Manifests**: Updates production Kubernetes manifests with new image
4. **Wait for ArgoCD**: Allows time for ArgoCD to sync changes
5. **Verify Deployment**: Runs health checks on production
6. **Rollback on Failure**: Automatically reverts to previous version if health checks fail
7. **Notify Success/Failure**: Creates deployment summary with all details

**Key Features**:
- ✅ Manual approval required (satisfies Requirement 6.1)
- ✅ 24-hour approval timeout (satisfies Requirement 6.5)
- ✅ Records approver and timestamp (satisfies Requirement 6.4)
- ✅ Automatic rollback on health check failure (satisfies Requirement 7.4)
- ✅ Deployment notifications with full details (satisfies Requirement 7.5)
- ✅ Rolling update strategy (satisfies Requirement 7.1)
- ✅ Backup of current state before deployment (satisfies Requirement 7.2)

**Setting up GitHub Environment Protection**:

To enable manual approval for production deployments:

1. Go to repository Settings → Environments
2. Click "New environment" and name it "production"
3. Enable "Required reviewers"
4. Add team members who can approve deployments
5. Set environment URL (optional): `https://production.yourdomain.com`
6. Save protection rules

Now when the production workflow runs, it will pause at the approval job and wait for a designated reviewer to approve before proceeding.

**Deployment Flow**:
```
Manual Trigger
     ↓
Approval Required (24h timeout)
     ↓
Backup Current Version
     ↓
Update Production Manifests
     ↓
Commit Changes
     ↓
Wait for ArgoCD Sync
     ↓
Verify Health Checks
     ↓
Success → Notify ✅
     or
Failure → Rollback → Notify ❌
```

## Related Documentation

- [CI/CD Overview](ci-cd-overview.md)
- [Branch Protection Setup](branch-protection-setup.md)
- [Deployment Guide](deployment-guide.md)
- [Troubleshooting Guide](../README.md#troubleshooting)

## Workflow Diagram

```
┌─────────────────────────────────────────────────────────┐
│                    Push / Pull Request                   │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
         ┌───────────────────────┐
         │  Install Dependencies │
         └───────────┬───────────┘
                     │
         ┌───────────┴───────────┐
         │                       │
         ▼                       ▼
    ┌────────┐            ┌──────────┐
    │  Lint  │            │   Test   │
    └────┬───┘            └─────┬────┘
         │                      │
         └──────────┬───────────┘
                    │
                    ▼
            ┌───────────────┐
            │ Build Docker  │
            └───────┬───────┘
                    │
                    ▼
            ┌───────────────┐
            │ Status Check  │
            └───────────────┘
                    │
                    ▼
            ┌───────────────┐
            │ ✅ CI Passed  │
            └───────────────┘
```

## Environment Variables

The CI workflow uses the following GitHub-provided environment variables:

- `GITHUB_SHA`: Commit SHA for image tagging
- `GITHUB_REF`: Branch or tag reference
- `GITHUB_REPOSITORY`: Repository name (used for GHCR image path)
- `GITHUB_TOKEN`: Authentication token for GHCR (automatically provided)
- `GITHUB_ACTOR`: Username for GHCR authentication
- `RUNNER_OS`: Operating system (ubuntu-latest)

No custom secrets are required for the CI workflow. The `GITHUB_TOKEN` is automatically provided by GitHub Actions with appropriate permissions.

## Future Enhancements

Potential improvements to consider:

1. **Parallel test execution**: Split tests across multiple runners
2. **Matrix builds**: Test on multiple Node.js versions
3. **Security scanning**: Add dependency vulnerability checks
4. **Code quality metrics**: Integrate SonarQube or similar
5. **Slack notifications**: Alert team on failures
6. **Performance benchmarks**: Track build and test times
7. **Automatic dependency updates**: Dependabot integration

## GitHub Container Registry (GHCR)

### Overview

The workflow automatically pushes Docker images to GitHub Container Registry after successful builds and tests. GHCR provides:
- Free container storage for public repositories
- Integrated with GitHub authentication
- Version tracking and management
- Easy access control

### Image Naming Convention

Images are pushed to: `ghcr.io/{owner}/{repository}`

Example: `ghcr.io/myusername/nodejs-cicd-pipeline`

### Tagging Strategy

Each successful build creates three tags:

1. **Commit SHA tag**: `{full-commit-sha}`
   - Immutable reference to specific commit
   - Example: `a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0`
   - Use for: Exact version tracking, rollbacks

2. **Semantic version tag**: `v{major}.{minor}.{patch}`
   - Based on version in package.json
   - Example: `v1.0.0`
   - Use for: Release management, production deployments

3. **Latest tag**: `latest`
   - Only created for main branch builds
   - Points to most recent successful build
   - Use for: Development, quick testing

### Accessing Images

**Pull an image**:
```bash
# Pull latest version
docker pull ghcr.io/{owner}/{repository}:latest

# Pull specific version
docker pull ghcr.io/{owner}/{repository}:v1.0.0

# Pull specific commit
docker pull ghcr.io/{owner}/{repository}:{commit-sha}
```

**Authentication** (for private repositories):
```bash
# Create personal access token with read:packages scope
echo $GITHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin

# Pull image
docker pull ghcr.io/{owner}/{repository}:latest
```

### Viewing Images

1. Go to repository main page on GitHub
2. Click "Packages" in right sidebar
3. View all published images and tags
4. See download statistics and usage

### Image Permissions

By default, images inherit repository visibility:
- Public repository → Public images
- Private repository → Private images

To change image visibility:
1. Go to package page
2. Click "Package settings"
3. Change visibility under "Danger Zone"

### Troubleshooting GHCR

**Problem**: Push to GHCR fails with authentication error

**Solutions**:
1. Verify `GITHUB_TOKEN` has `write:packages` permission
2. Check repository settings → Actions → General → Workflow permissions
3. Ensure "Read and write permissions" is enabled
4. Re-run workflow after updating permissions

**Problem**: Image not visible in packages

**Solutions**:
1. Check workflow logs for push errors
2. Verify build job completed successfully
3. Wait a few minutes for GitHub to process
4. Check package visibility settings

**Problem**: Cannot pull image

**Solutions**:
1. Verify image name and tag are correct
2. Authenticate with `docker login ghcr.io` for private images
3. Check you have read access to repository
4. Use full image path including `ghcr.io/` prefix

## Compliance

This CI workflow satisfies the following requirements:

- **4.1**: Automatic trigger on code push ✅
- **4.2**: Dependency installation with integrity verification ✅
- **4.3**: Automated test execution with failure handling ✅
- **4.4**: Code linting and style checks ✅
- **4.5**: Docker image building with commit SHA tagging ✅
- **10.4**: CI runs on pull requests before merge ✅
- **11.4**: Uses GitHub Actions as CI/CD platform ✅
- **11.6**: Uses GitHub Container Registry for artifact storage ✅
- **13.1**: Tags images with Git commit SHA ✅
- **13.2**: Tags images with semantic version ✅
- **13.3**: Requires authentication for GHCR access ✅
- **13.4**: Verifies push succeeded in workflow ✅
